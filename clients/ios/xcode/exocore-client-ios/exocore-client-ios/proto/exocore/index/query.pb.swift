// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: exocore/index/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Exocore_Index_EntityResultSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case pending // = 1
  case chain // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .pending
    case 2: self = .chain
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .pending: return 1
    case .chain: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Exocore_Index_EntityResultSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Exocore_Index_EntityResultSource] = [
    .unknown,
    .pending,
    .chain,
  ]
}

#endif  // swift(>=4.2)

public struct Exocore_Index_EntityQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var predicate: OneOf_Predicate? {
    get {return _storage._predicate}
    set {_uniqueStorage()._predicate = newValue}
  }

  public var match: Exocore_Index_MatchPredicate {
    get {
      if case .match(let v)? = _storage._predicate {return v}
      return Exocore_Index_MatchPredicate()
    }
    set {_uniqueStorage()._predicate = .match(newValue)}
  }

  public var trait: Exocore_Index_TraitPredicate {
    get {
      if case .trait(let v)? = _storage._predicate {return v}
      return Exocore_Index_TraitPredicate()
    }
    set {_uniqueStorage()._predicate = .trait(newValue)}
  }

  public var ids: Exocore_Index_IdsPredicate {
    get {
      if case .ids(let v)? = _storage._predicate {return v}
      return Exocore_Index_IdsPredicate()
    }
    set {_uniqueStorage()._predicate = .ids(newValue)}
  }

  public var reference: Exocore_Index_ReferencePredicate {
    get {
      if case .reference(let v)? = _storage._predicate {return v}
      return Exocore_Index_ReferencePredicate()
    }
    set {_uniqueStorage()._predicate = .reference(newValue)}
  }

  public var operations: Exocore_Index_OperationsPredicate {
    get {
      if case .operations(let v)? = _storage._predicate {return v}
      return Exocore_Index_OperationsPredicate()
    }
    set {_uniqueStorage()._predicate = .operations(newValue)}
  }

  public var all: Exocore_Index_AllPredicate {
    get {
      if case .all(let v)? = _storage._predicate {return v}
      return Exocore_Index_AllPredicate()
    }
    set {_uniqueStorage()._predicate = .all(newValue)}
  }

  public var test: Exocore_Index_TestPredicate {
    get {
      if case .test(let v)? = _storage._predicate {return v}
      return Exocore_Index_TestPredicate()
    }
    set {_uniqueStorage()._predicate = .test(newValue)}
  }

  //// Query paging requested
  public var paging: Exocore_Index_Paging {
    get {return _storage._paging ?? Exocore_Index_Paging()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  //// Query ordering
  public var ordering: Exocore_Index_Ordering {
    get {return _storage._ordering ?? Exocore_Index_Ordering()}
    set {_uniqueStorage()._ordering = newValue}
  }
  /// Returns true if `ordering` has been explicitly set.
  public var hasOrdering: Bool {return _storage._ordering != nil}
  /// Clears the value of `ordering`. Subsequent reads from it will return its default value.
  public mutating func clearOrdering() {_uniqueStorage()._ordering = nil}

  //// If true, only return summary
  public var summary: Bool {
    get {return _storage._summary}
    set {_uniqueStorage()._summary = newValue}
  }

  //// Optional watch token if this query is to be used for watching.
  public var watchToken: UInt64 {
    get {return _storage._watchToken}
    set {_uniqueStorage()._watchToken = newValue}
  }

  //// If specified, if results from server matches this hash, only a summary will be returned.
  public var resultHash: UInt64 {
    get {return _storage._resultHash}
    set {_uniqueStorage()._resultHash = newValue}
  }

  //// Include deleted mutations matches. Can be used to return recently modified entities that
  //// also include deletions.
  public var includeDeleted: Bool {
    get {return _storage._includeDeleted}
    set {_uniqueStorage()._includeDeleted = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Predicate: Equatable {
    case match(Exocore_Index_MatchPredicate)
    case trait(Exocore_Index_TraitPredicate)
    case ids(Exocore_Index_IdsPredicate)
    case reference(Exocore_Index_ReferencePredicate)
    case operations(Exocore_Index_OperationsPredicate)
    case all(Exocore_Index_AllPredicate)
    case test(Exocore_Index_TestPredicate)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Index_EntityQuery.OneOf_Predicate, rhs: Exocore_Index_EntityQuery.OneOf_Predicate) -> Bool {
      switch (lhs, rhs) {
      case (.match(let l), .match(let r)): return l == r
      case (.trait(let l), .trait(let r)): return l == r
      case (.ids(let l), .ids(let r)): return l == r
      case (.reference(let l), .reference(let r)): return l == r
      case (.operations(let l), .operations(let r)): return l == r
      case (.all(let l), .all(let r)): return l == r
      case (.test(let l), .test(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// Query entities by text match on all indexed fields across all traits.
public struct Exocore_Index_MatchPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities by IDs.
public struct Exocore_Index_IdsPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities by mutations' operation ids.
//// Used to return entities on which mutations with these operation ids were applied and indexed.
public struct Exocore_Index_OperationsPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operationIds: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query all entities.
public struct Exocore_Index_AllPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Used for tests.
public struct Exocore_Index_TestPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities that have a specified trait and optionally matching a trait query.
public struct Exocore_Index_TraitPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var traitName: String {
    get {return _storage._traitName}
    set {_uniqueStorage()._traitName = newValue}
  }

  public var query: Exocore_Index_TraitQuery {
    get {return _storage._query ?? Exocore_Index_TraitQuery()}
    set {_uniqueStorage()._query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return _storage._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {_uniqueStorage()._query = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Exocore_Index_TraitQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var predicate: OneOf_Predicate? {
    get {return _storage._predicate}
    set {_uniqueStorage()._predicate = newValue}
  }

  public var match: Exocore_Index_MatchPredicate {
    get {
      if case .match(let v)? = _storage._predicate {return v}
      return Exocore_Index_MatchPredicate()
    }
    set {_uniqueStorage()._predicate = .match(newValue)}
  }

  public var field: Exocore_Index_TraitFieldPredicate {
    get {
      if case .field(let v)? = _storage._predicate {return v}
      return Exocore_Index_TraitFieldPredicate()
    }
    set {_uniqueStorage()._predicate = .field(newValue)}
  }

  public var reference: Exocore_Index_TraitFieldReferencePredicate {
    get {
      if case .reference(let v)? = _storage._predicate {return v}
      return Exocore_Index_TraitFieldReferencePredicate()
    }
    set {_uniqueStorage()._predicate = .reference(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Predicate: Equatable {
    case match(Exocore_Index_MatchPredicate)
    case field(Exocore_Index_TraitFieldPredicate)
    case reference(Exocore_Index_TraitFieldReferencePredicate)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Index_TraitQuery.OneOf_Predicate, rhs: Exocore_Index_TraitQuery.OneOf_Predicate) -> Bool {
      switch (lhs, rhs) {
      case (.match(let l), .match(let r)): return l == r
      case (.field(let l), .field(let r)): return l == r
      case (.reference(let l), .reference(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Exocore_Index_TraitFieldPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String {
    get {return _storage._field}
    set {_uniqueStorage()._field = newValue}
  }

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  public var string: String {
    get {
      if case .string(let v)? = _storage._value {return v}
      return String()
    }
    set {_uniqueStorage()._value = .string(newValue)}
  }

  public var int64: Int64 {
    get {
      if case .int64(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .int64(newValue)}
  }

  public var uint64: UInt64 {
    get {
      if case .uint64(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .uint64(newValue)}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .date(let v)? = _storage._value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {_uniqueStorage()._value = .date(newValue)}
  }

  public var `operator`: Exocore_Index_TraitFieldPredicate.Operator {
    get {return _storage._operator}
    set {_uniqueStorage()._operator = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case string(String)
    case int64(Int64)
    case uint64(UInt64)
    case date(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Index_TraitFieldPredicate.OneOf_Value, rhs: Exocore_Index_TraitFieldPredicate.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.string(let l), .string(let r)): return l == r
      case (.int64(let l), .int64(let r)): return l == r
      case (.uint64(let l), .uint64(let r)): return l == r
      case (.date(let l), .date(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum Operator: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case equal // = 0
    case gt // = 1
    case gte // = 2
    case lt // = 3
    case lte // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .equal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .equal
      case 1: self = .gt
      case 2: self = .gte
      case 3: self = .lt
      case 4: self = .lte
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .equal: return 0
      case .gt: return 1
      case .gte: return 2
      case .lt: return 3
      case .lte: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Exocore_Index_TraitFieldPredicate.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Exocore_Index_TraitFieldPredicate.Operator] = [
    .equal,
    .gt,
    .gte,
    .lt,
    .lte,
  ]
}

#endif  // swift(>=4.2)

public struct Exocore_Index_TraitFieldReferencePredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String {
    get {return _storage._field}
    set {_uniqueStorage()._field = newValue}
  }

  public var reference: Exocore_Index_ReferencePredicate {
    get {return _storage._reference ?? Exocore_Index_ReferencePredicate()}
    set {_uniqueStorage()._reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return _storage._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {_uniqueStorage()._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Exocore_Index_ReferencePredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entity id the reference points to
  public var entityID: String = String()

  /// Optional trait id the reference points to
  public var traitID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Exocore_Index_Paging {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Returns results after this given ordering value.
  public var afterOrderingValue: Exocore_Index_OrderingValue {
    get {return _storage._afterOrderingValue ?? Exocore_Index_OrderingValue()}
    set {_uniqueStorage()._afterOrderingValue = newValue}
  }
  /// Returns true if `afterOrderingValue` has been explicitly set.
  public var hasAfterOrderingValue: Bool {return _storage._afterOrderingValue != nil}
  /// Clears the value of `afterOrderingValue`. Subsequent reads from it will return its default value.
  public mutating func clearAfterOrderingValue() {_uniqueStorage()._afterOrderingValue = nil}

  //// Returns results before this given ordering value.
  public var beforeOrderingValue: Exocore_Index_OrderingValue {
    get {return _storage._beforeOrderingValue ?? Exocore_Index_OrderingValue()}
    set {_uniqueStorage()._beforeOrderingValue = newValue}
  }
  /// Returns true if `beforeOrderingValue` has been explicitly set.
  public var hasBeforeOrderingValue: Bool {return _storage._beforeOrderingValue != nil}
  /// Clears the value of `beforeOrderingValue`. Subsequent reads from it will return its default value.
  public mutating func clearBeforeOrderingValue() {_uniqueStorage()._beforeOrderingValue = nil}

  //// Desired results count. Default if 0.
  public var count: UInt32 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Exocore_Index_Ordering {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Value by which we want results to be ordered.
  public var value: Exocore_Index_Ordering.OneOf_Value? = nil

  public var score: Bool {
    get {
      if case .score(let v)? = value {return v}
      return false
    }
    set {value = .score(newValue)}
  }

  public var operationID: Bool {
    get {
      if case .operationID(let v)? = value {return v}
      return false
    }
    set {value = .operationID(newValue)}
  }

  public var field: String {
    get {
      if case .field(let v)? = value {return v}
      return String()
    }
    set {value = .field(newValue)}
  }

  //// Direction of ordering.
  public var ascending: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// Value by which we want results to be ordered.
  public enum OneOf_Value: Equatable {
    case score(Bool)
    case operationID(Bool)
    case field(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Index_Ordering.OneOf_Value, rhs: Exocore_Index_Ordering.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.score(let l), .score(let r)): return l == r
      case (.operationID(let l), .operationID(let r)): return l == r
      case (.field(let l), .field(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Exocore_Index_OrderingValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  public var float: Float {
    get {
      if case .float(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .float(newValue)}
  }

  public var uint64: UInt64 {
    get {
      if case .uint64(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .uint64(newValue)}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .date(let v)? = _storage._value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {_uniqueStorage()._value = .date(newValue)}
  }

  public var min: Bool {
    get {
      if case .min(let v)? = _storage._value {return v}
      return false
    }
    set {_uniqueStorage()._value = .min(newValue)}
  }

  public var max: Bool {
    get {
      if case .max(let v)? = _storage._value {return v}
      return false
    }
    set {_uniqueStorage()._value = .max(newValue)}
  }

  //// ID operation used to tie break equal results
  public var operationID: UInt64 {
    get {return _storage._operationID}
    set {_uniqueStorage()._operationID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case float(Float)
    case uint64(UInt64)
    case date(SwiftProtobuf.Google_Protobuf_Timestamp)
    case min(Bool)
    case max(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Index_OrderingValue.OneOf_Value, rhs: Exocore_Index_OrderingValue.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.float(let l), .float(let r)): return l == r
      case (.uint64(let l), .uint64(let r)): return l == r
      case (.date(let l), .date(let r)): return l == r
      case (.min(let l), .min(let r)): return l == r
      case (.max(let l), .max(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Exocore_Index_EntityResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entities: [Exocore_Index_EntityResult] {
    get {return _storage._entities}
    set {_uniqueStorage()._entities = newValue}
  }

  public var summary: Bool {
    get {return _storage._summary}
    set {_uniqueStorage()._summary = newValue}
  }

  public var estimatedCount: UInt32 {
    get {return _storage._estimatedCount}
    set {_uniqueStorage()._estimatedCount = newValue}
  }

  public var currentPage: Exocore_Index_Paging {
    get {return _storage._currentPage ?? Exocore_Index_Paging()}
    set {_uniqueStorage()._currentPage = newValue}
  }
  /// Returns true if `currentPage` has been explicitly set.
  public var hasCurrentPage: Bool {return _storage._currentPage != nil}
  /// Clears the value of `currentPage`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPage() {_uniqueStorage()._currentPage = nil}

  public var nextPage: Exocore_Index_Paging {
    get {return _storage._nextPage ?? Exocore_Index_Paging()}
    set {_uniqueStorage()._nextPage = newValue}
  }
  /// Returns true if `nextPage` has been explicitly set.
  public var hasNextPage: Bool {return _storage._nextPage != nil}
  /// Clears the value of `nextPage`. Subsequent reads from it will return its default value.
  public mutating func clearNextPage() {_uniqueStorage()._nextPage = nil}

  public var hash: UInt64 {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Exocore_Index_EntityResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entity: Exocore_Index_Entity {
    get {return _storage._entity ?? Exocore_Index_Entity()}
    set {_uniqueStorage()._entity = newValue}
  }
  /// Returns true if `entity` has been explicitly set.
  public var hasEntity: Bool {return _storage._entity != nil}
  /// Clears the value of `entity`. Subsequent reads from it will return its default value.
  public mutating func clearEntity() {_uniqueStorage()._entity = nil}

  public var source: Exocore_Index_EntityResultSource {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  public var orderingValue: Exocore_Index_OrderingValue {
    get {return _storage._orderingValue ?? Exocore_Index_OrderingValue()}
    set {_uniqueStorage()._orderingValue = newValue}
  }
  /// Returns true if `orderingValue` has been explicitly set.
  public var hasOrderingValue: Bool {return _storage._orderingValue != nil}
  /// Clears the value of `orderingValue`. Subsequent reads from it will return its default value.
  public mutating func clearOrderingValue() {_uniqueStorage()._orderingValue = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "exocore.index"

extension Exocore_Index_EntityResultSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "CHAIN"),
  ]
}

extension Exocore_Index_EntityQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
    2: .same(proto: "trait"),
    3: .same(proto: "ids"),
    4: .same(proto: "reference"),
    10: .same(proto: "operations"),
    11: .same(proto: "all"),
    99: .same(proto: "test"),
    5: .same(proto: "paging"),
    6: .same(proto: "ordering"),
    7: .same(proto: "summary"),
    8: .standard(proto: "watch_token"),
    9: .standard(proto: "result_hash"),
    12: .standard(proto: "include_deleted"),
  ]

  fileprivate class _StorageClass {
    var _predicate: Exocore_Index_EntityQuery.OneOf_Predicate?
    var _paging: Exocore_Index_Paging? = nil
    var _ordering: Exocore_Index_Ordering? = nil
    var _summary: Bool = false
    var _watchToken: UInt64 = 0
    var _resultHash: UInt64 = 0
    var _includeDeleted: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _predicate = source._predicate
      _paging = source._paging
      _ordering = source._ordering
      _summary = source._summary
      _watchToken = source._watchToken
      _resultHash = source._resultHash
      _includeDeleted = source._includeDeleted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Exocore_Index_MatchPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .match(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .match(v)}
        case 2:
          var v: Exocore_Index_TraitPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .trait(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .trait(v)}
        case 3:
          var v: Exocore_Index_IdsPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .ids(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .ids(v)}
        case 4:
          var v: Exocore_Index_ReferencePredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .reference(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .reference(v)}
        case 5: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._ordering)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._summary)
        case 8: try decoder.decodeSingularUInt64Field(value: &_storage._watchToken)
        case 9: try decoder.decodeSingularUInt64Field(value: &_storage._resultHash)
        case 10:
          var v: Exocore_Index_OperationsPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .operations(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .operations(v)}
        case 11:
          var v: Exocore_Index_AllPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .all(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .all(v)}
        case 12: try decoder.decodeSingularBoolField(value: &_storage._includeDeleted)
        case 99:
          var v: Exocore_Index_TestPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .test(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .test(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._predicate {
      case .match(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .trait(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .ids(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .reference(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      default: break
      }
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._ordering {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._summary != false {
        try visitor.visitSingularBoolField(value: _storage._summary, fieldNumber: 7)
      }
      if _storage._watchToken != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._watchToken, fieldNumber: 8)
      }
      if _storage._resultHash != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._resultHash, fieldNumber: 9)
      }
      switch _storage._predicate {
      case .operations(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .all(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case nil: break
      default: break
      }
      if _storage._includeDeleted != false {
        try visitor.visitSingularBoolField(value: _storage._includeDeleted, fieldNumber: 12)
      }
      if case .test(let v)? = _storage._predicate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_EntityQuery, rhs: Exocore_Index_EntityQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._predicate != rhs_storage._predicate {return false}
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._ordering != rhs_storage._ordering {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._watchToken != rhs_storage._watchToken {return false}
        if _storage._resultHash != rhs_storage._resultHash {return false}
        if _storage._includeDeleted != rhs_storage._includeDeleted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_MatchPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.query)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_MatchPredicate, rhs: Exocore_Index_MatchPredicate) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_IdsPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdsPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.ids)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_IdsPredicate, rhs: Exocore_Index_IdsPredicate) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_OperationsPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationsPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.operationIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.operationIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_OperationsPredicate, rhs: Exocore_Index_OperationsPredicate) -> Bool {
    if lhs.operationIds != rhs.operationIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_AllPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllPredicate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_AllPredicate, rhs: Exocore_Index_AllPredicate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_TestPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_TestPredicate, rhs: Exocore_Index_TestPredicate) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_TraitPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trait_name"),
    2: .same(proto: "query"),
  ]

  fileprivate class _StorageClass {
    var _traitName: String = String()
    var _query: Exocore_Index_TraitQuery? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _traitName = source._traitName
      _query = source._query
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._traitName)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._query)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._traitName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._traitName, fieldNumber: 1)
      }
      if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_TraitPredicate, rhs: Exocore_Index_TraitPredicate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._traitName != rhs_storage._traitName {return false}
        if _storage._query != rhs_storage._query {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_TraitQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
    2: .same(proto: "field"),
    3: .same(proto: "reference"),
  ]

  fileprivate class _StorageClass {
    var _predicate: Exocore_Index_TraitQuery.OneOf_Predicate?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _predicate = source._predicate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Exocore_Index_MatchPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .match(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .match(v)}
        case 2:
          var v: Exocore_Index_TraitFieldPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .field(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .field(v)}
        case 3:
          var v: Exocore_Index_TraitFieldReferencePredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .reference(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .reference(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._predicate {
      case .match(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .field(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .reference(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_TraitQuery, rhs: Exocore_Index_TraitQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._predicate != rhs_storage._predicate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_TraitFieldPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitFieldPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "string"),
    3: .same(proto: "int64"),
    4: .same(proto: "uint64"),
    5: .same(proto: "date"),
    6: .same(proto: "operator"),
  ]

  fileprivate class _StorageClass {
    var _field: String = String()
    var _value: Exocore_Index_TraitFieldPredicate.OneOf_Value?
    var _operator: Exocore_Index_TraitFieldPredicate.Operator = .equal

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _field = source._field
      _value = source._value
      _operator = source._operator
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._field)
        case 2:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._value = .string(v)}
        case 3:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {_storage._value = .int64(v)}
        case 4:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {_storage._value = .uint64(v)}
        case 5:
          var v: SwiftProtobuf.Google_Protobuf_Timestamp?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .date(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .date(v)}
        case 6: try decoder.decodeSingularEnumField(value: &_storage._operator)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._field.isEmpty {
        try visitor.visitSingularStringField(value: _storage._field, fieldNumber: 1)
      }
      switch _storage._value {
      case .string(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .int64(let v)?:
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
      case .uint64(let v)?:
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      case .date(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
      if _storage._operator != .equal {
        try visitor.visitSingularEnumField(value: _storage._operator, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_TraitFieldPredicate, rhs: Exocore_Index_TraitFieldPredicate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._field != rhs_storage._field {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._operator != rhs_storage._operator {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_TraitFieldPredicate.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EQUAL"),
    1: .same(proto: "GT"),
    2: .same(proto: "GTE"),
    3: .same(proto: "LT"),
    4: .same(proto: "LTE"),
  ]
}

extension Exocore_Index_TraitFieldReferencePredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitFieldReferencePredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "reference"),
  ]

  fileprivate class _StorageClass {
    var _field: String = String()
    var _reference: Exocore_Index_ReferencePredicate? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _field = source._field
      _reference = source._reference
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._field)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._reference)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._field.isEmpty {
        try visitor.visitSingularStringField(value: _storage._field, fieldNumber: 1)
      }
      if let v = _storage._reference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_TraitFieldReferencePredicate, rhs: Exocore_Index_TraitFieldReferencePredicate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._field != rhs_storage._field {return false}
        if _storage._reference != rhs_storage._reference {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_ReferencePredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReferencePredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .standard(proto: "trait_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.entityID)
      case 2: try decoder.decodeSingularStringField(value: &self.traitID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 1)
    }
    if !self.traitID.isEmpty {
      try visitor.visitSingularStringField(value: self.traitID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_ReferencePredicate, rhs: Exocore_Index_ReferencePredicate) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.traitID != rhs.traitID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_Paging: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Paging"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "after_ordering_value"),
    2: .standard(proto: "before_ordering_value"),
    3: .same(proto: "count"),
  ]

  fileprivate class _StorageClass {
    var _afterOrderingValue: Exocore_Index_OrderingValue? = nil
    var _beforeOrderingValue: Exocore_Index_OrderingValue? = nil
    var _count: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _afterOrderingValue = source._afterOrderingValue
      _beforeOrderingValue = source._beforeOrderingValue
      _count = source._count
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._afterOrderingValue)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._beforeOrderingValue)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._count)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._afterOrderingValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._beforeOrderingValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._count != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._count, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_Paging, rhs: Exocore_Index_Paging) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._afterOrderingValue != rhs_storage._afterOrderingValue {return false}
        if _storage._beforeOrderingValue != rhs_storage._beforeOrderingValue {return false}
        if _storage._count != rhs_storage._count {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_Ordering: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ordering"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .standard(proto: "operation_id"),
    3: .same(proto: "field"),
    4: .same(proto: "ascending"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .score(v)}
      case 2:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .operationID(v)}
      case 3:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .field(v)}
      case 4: try decoder.decodeSingularBoolField(value: &self.ascending)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.value {
    case .score(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    case .operationID(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    case .field(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case nil: break
    }
    if self.ascending != false {
      try visitor.visitSingularBoolField(value: self.ascending, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_Ordering, rhs: Exocore_Index_Ordering) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.ascending != rhs.ascending {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_OrderingValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderingValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "float"),
    2: .same(proto: "uint64"),
    3: .same(proto: "date"),
    4: .same(proto: "min"),
    5: .same(proto: "max"),
    6: .standard(proto: "operation_id"),
  ]

  fileprivate class _StorageClass {
    var _value: Exocore_Index_OrderingValue.OneOf_Value?
    var _operationID: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _operationID = source._operationID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {_storage._value = .float(v)}
        case 2:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {_storage._value = .uint64(v)}
        case 3:
          var v: SwiftProtobuf.Google_Protobuf_Timestamp?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .date(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .date(v)}
        case 4:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._value = .min(v)}
        case 5:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._value = .max(v)}
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._operationID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._value {
      case .float(let v)?:
        try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
      case .uint64(let v)?:
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      case .date(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .min(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      case .max(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      case nil: break
      }
      if _storage._operationID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._operationID, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_OrderingValue, rhs: Exocore_Index_OrderingValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._operationID != rhs_storage._operationID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_EntityResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entities"),
    2: .same(proto: "summary"),
    3: .standard(proto: "estimated_count"),
    4: .standard(proto: "current_page"),
    5: .standard(proto: "next_page"),
    6: .same(proto: "hash"),
  ]

  fileprivate class _StorageClass {
    var _entities: [Exocore_Index_EntityResult] = []
    var _summary: Bool = false
    var _estimatedCount: UInt32 = 0
    var _currentPage: Exocore_Index_Paging? = nil
    var _nextPage: Exocore_Index_Paging? = nil
    var _hash: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entities = source._entities
      _summary = source._summary
      _estimatedCount = source._estimatedCount
      _currentPage = source._currentPage
      _nextPage = source._nextPage
      _hash = source._hash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._entities)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._summary)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._estimatedCount)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._currentPage)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._nextPage)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._hash)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._entities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._entities, fieldNumber: 1)
      }
      if _storage._summary != false {
        try visitor.visitSingularBoolField(value: _storage._summary, fieldNumber: 2)
      }
      if _storage._estimatedCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._estimatedCount, fieldNumber: 3)
      }
      if let v = _storage._currentPage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._nextPage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._hash != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._hash, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_EntityResults, rhs: Exocore_Index_EntityResults) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entities != rhs_storage._entities {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._estimatedCount != rhs_storage._estimatedCount {return false}
        if _storage._currentPage != rhs_storage._currentPage {return false}
        if _storage._nextPage != rhs_storage._nextPage {return false}
        if _storage._hash != rhs_storage._hash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Index_EntityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entity"),
    2: .same(proto: "source"),
    3: .standard(proto: "ordering_value"),
  ]

  fileprivate class _StorageClass {
    var _entity: Exocore_Index_Entity? = nil
    var _source: Exocore_Index_EntityResultSource = .unknown
    var _orderingValue: Exocore_Index_OrderingValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entity = source._entity
      _source = source._source
      _orderingValue = source._orderingValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._entity)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._source)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._orderingValue)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._source != .unknown {
        try visitor.visitSingularEnumField(value: _storage._source, fieldNumber: 2)
      }
      if let v = _storage._orderingValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Index_EntityResult, rhs: Exocore_Index_EntityResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entity != rhs_storage._entity {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._orderingValue != rhs_storage._orderingValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
